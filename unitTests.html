<!--
Copyright (C) 2023 VIRNECT CO., LTD.
All rights reserved.

Unittests page for execution of WASN unit tests on web browser
For usage please refer to \VARUTILS\WebUnitTest\run.py
-->
<html>
<head>
    <style>
        body {
            background-color: #eee;
        }

        h3 {
            margin: 0;
        }

        td {
            border: 1px solid black;
            background-color: white;
            vertical-align: top;
        }

        table {
            width: 100%;
        }

        p {
            margin: 0;
        }

        #run {
            background-color: limegreen;
            color: white;
        }

        #run:disabled {
            background-color: gray;
        }
    </style>
</head>
<body>
    <h1><p id="header">WASM UNIT TEST</p></h1>
    <div id="inputs" style="display: none">
        <input list="tests" oninput="selectTest(event)">
        <datalist id="tests">
        </datalist>
        <button id="run" onclick="runUnitTests()">Run</button>
    </div>
    </p>
    <table>
        <tr>
            <th align="left"><h3>Info:</h3></th>
        </tr>
        <tr>
            <td>
                <p>
                    This HTML page allows to run EMSCRIPTEN compiled VARVision and VARSDK WASM unit tests within the Chrome Webbrowser.</br>
                    It should only be used in a Chrome instance started by the <b>\VARUTILS\WebUnitTest\run.py</b> python script!</br>
                    The artifacts generated by the unit tests will be available via download links in the table below. Artifacts are NOT downloaded automatically.</br></br>
                    Depending on the flags provided to the python script (--autoClose), this page will either close automatically or stays open after the unit tests finished.
                </p>
            </td>
        </tr>
    </table>
    <table>
        <tr>
            <th align="left"><h3>Status:</h3></th>
        </tr>
        <tr>
            <td>
                <p>
                    This page will <b id="autoClose">NOT CLOSE AUTOMATICALLY. Please close this browser window manually</b>.
                </p>
                <p id="status"></p>
                <p id="statusERROR" style="color:#FF0000"></p>
            </td>
        </tr>
    </table>
    </br>
    <table>
        <tr>
            <th align="left"><h3>Available Resources:</h3></th>
            <th align="left"><h3>Downloadable Artifacts:</h3></th>
        </tr>
        <tr>
            <td><p id="resourceList"></p></td>
            <td><p id="downloadLinks" style="color:#40cb25"></p></td>
        </tr>
    </table>
</body>
<script>

    var rootName = "unknown"; // Display name of repository
    var autoClose = false;    // Autoclose information flag - only for text representation, no build in effect
    var runAll = false;       // Whether to run all tests
    var run = ""              // Colon separated list of tests to execute
    var unitTestModule;       // Unit test module

    // Extract params given by python script form URL
    function getURLParamHeader() {
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);
        if (urlParams.has('root'))
            rootName = urlParams.get('root')
        document.getElementById("header").innerHTML += " for " + rootName;

        if (urlParams.has('autoClose')) {
            autoClose = true;
            document.getElementById("autoClose").innerHTML = "AUTOMATICALLY CLOSE " + urlParams.get('autoClose') + " SECONDS AFTER IT OPENED"; // Termination is handled via python script
        }

        if (urlParams.has('run')) {
            run = urlParams.get('run');
        }

        if (urlParams.has('select') && urlParams.get('select')) {
            document.getElementById("inputs").style.display = "block";
        } else {
            runAll = true;
        }
    }
    getURLParamHeader();

    // Attach paragraph element with text node to given DOM id
    function logElement(text, id) {
        console.log(text)
        const para = document.createElement("p");
        const textnode = document.createTextNode(text);
        para.appendChild(textnode)
        document.getElementById(id).appendChild(para);
    }

    // Log to status DOM section
    function logStatus(text) {
        logElement("- " + text, "status");
    }

    // Log to error DOM section
    function logError(text) {
        logElement("!!! " + text, "statusERROR");
    }

    // Log to resource DOM section
    function logResource(text) {
        logElement(text, "resourceList");
    }

    // Function called after execution is finished
    // Unclear if ^exit^0 or ^exit^1 has an effect
    // TODO - clarify functionality
    var postExit = msg => {
        logStatus("postExit - called");
        var http = new XMLHttpRequest;
        http.open('POST', 'unitTests.html', true); // Original stdio.html Caused error
        http.send(msg);
    };

    // Main execution
    // Cross-loads unitTest.js file which executes WASM modules
    // Retrieves a list of all tests or executes all selected tests
    const setupUnitTests = async () => {
        try {
            logStatus("running unitTests.js - logs will show once execution is finished");
            unitTestModule = (await import('./unitTests.js')
                .then((result) => result.default())
                .catch((error) => logError("ERROR: " + error)));
            if (unitTestModule == null) {
                logError("ERROR: unitTestModule is null - ABORTING EXECUTION");
                return;
            }

            const tests = unitTestModule.listGTestTests();

            const testsSelectElem = document.getElementById("tests");
            tests.forEach(item => {
                const option = document.createElement('option');
                option.value = item;
                testsSelectElem.appendChild(option);
            });

            if (run)
                unitTestModule.setGTestFilter(run);

            if (run || runAll)
                runUnitTests();
        }
        catch (error) {
            logError("ERROR: " + error);
        }
    }

    function selectTest(event) {
        unitTestModule.setGTestFilter(event.target.value);
    }

    // Main execution
    // Starts unit test execution
    // Creates FS lists (resources + downloads)
    const runUnitTests = async () => {
        try {
            // hide input elements, might be already hidden but in case of --select they should disappear after pressing run
            document.getElementById("inputs").style.display = "none";

            logStatus("starting unit test execution");

            const status = unitTestModule.runGTest();

            if (status === 0) {
                logStatus("unit tests finished with status " + status);
            } else {
                logError("ERROR: unit tests finished with status " + status + " Please check the console logs");
                unitTestModule.PThread.terminateAllThreads();
            }

            listResources(unitTestModule, 'resource', 'resource');
            listArtefacts(unitTestModule, 'bin', 'bin')

            // Downloading multiple files at once will be blocked by chrome
            // downloadAll();

            // TODO: Purpose of original postExit implementation is unclear
            postExit('^exit^' + status);

            // Closing window is prevented by security feature of chrome
            // if (autoClose)
            //     window.close()

            logStatus("DONE - you can close the browser now");
        }
        catch (error) {
            logError("ERROR: " + error);
        }
    };

    // Appends clickable HREF for each artifact in artifacts cell
    function createDownloadLink(module, filepath) {
        try {
            const content = module.FS.readFile(filepath);
            blob = new Blob([content], { type: 'application/octet-stream' });
            console.log(`Offering download of "${filepath}", with ${blob.size} bytes...`);

            // Create link
            const a = document.createElement('a');
            a.download = filepath;
            a.href = URL.createObjectURL(blob);
            a.id = "downloadableArtifact"
            a.text = filepath;

            // Attach to DOM
            document.body.appendChild(a);
            const para = document.createElement("p");
            para.appendChild(a)
            document.getElementById("downloadLinks").appendChild(para);
        }
        catch (error) {
            logError("ERROR: createDownloadLink(%s) - %s" % filepath, error);
        }
    }

    // Recursive function to list downloadable artifacts
    function listArtefacts(module, path, prefix) {
        const artifacts = module.FS.readdir(path)
        // Slice is needed to remove "." and ".."
        artifacts.slice(2).forEach(function (entry) {
            fullpath = path + "/" + entry
            mode = module.FS.lstat(fullpath).mode
            try {
                if (module.FS.isDir(mode))
                    listArtefacts(module, fullpath, prefix + "/" + entry);
                else
                    createDownloadLink(module, fullpath);
            } catch (exception) {
                console.error(fullpath + "  ERROR:  " + exception);
            }
        }
        );
    }

    // Recursive function to list files in FS
    function listResources(module, path, prefix) {
        const artifacts = module.FS.readdir(path)
        // Slice is needed to remove "." and ".."
        artifacts.slice(2).forEach(function (entry) {
            fullpath = path + "/" + entry
            mode = module.FS.lstat(fullpath).mode
            try {
                logResource(prefix + "/" + entry);
                if (module.FS.isDir(mode))
                    listResources(module, fullpath, prefix + "/" + entry);
            } catch (exception) {
                console.error(fullpath + "  ERROR:  " + exception);
            }
        }
        );
    }

    // Performs CLICK action on each HREF in downloadLinks - currently unused
    function downloadAll() {
        const links = [...document.getElementById('downloadLinks').children];
        links.forEach(l => l.children[0].click())
    }

    // Execute script with timeout after page finished loading
    window.addEventListener("load", async e => {
        setTimeout(await setupUnitTests(), 1);
    });

</script>
</html>